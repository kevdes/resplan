'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * @fileOverview calculate tick values of scale
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * @author xile611, arcthur
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * @date 2015-09-17
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = require('./util/utils');

var _arithmetic = require('./util/arithmetic');

var _arithmetic2 = _interopRequireDefault(_arithmetic);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * 判断是否为合法的区间，并返回处理后的合法区间
 *
 * @param  {Number} min       最小值
 * @param  {Number} max       最大值
 * @return {Array} 最小最大值数组
 */
function getValidInterval(_ref) {
  var _ref2 = _slicedToArray(_ref, 2);

  var min = _ref2[0];
  var max = _ref2[1];
  var validMin = min;
  var validMax = max;

  // 交换最大值和最小值

  if (min > max) {
    validMin = max;
    validMax = min;
  }

  return [validMin, validMax];
}

/**
 * 计算可读性高的刻度间距，如 10, 20
 *
 * @param  {Number}  roughStep 计算的原始间隔
 * @param  {Integer} amendIndex 修正系数
 * @return {Number}  刻度间距
 */
function getFormatStep(roughStep, amendIndex) {
  if (roughStep <= 0) {
    return 0;
  }

  var digitCount = _arithmetic2.default.getDigitCount(roughStep);
  // 间隔数与上一个数量级的占比
  var stepRatio = roughStep / Math.pow(10, digitCount);

  // 整数与浮点数相乘，需要处理JS精度问题
  var amendStepRatio = _arithmetic2.default.multiply(Math.ceil(stepRatio / 0.05) + amendIndex, 0.05);

  var formatStep = _arithmetic2.default.multiply(amendStepRatio, Math.pow(10, digitCount));

  return formatStep;
}

/**
 * 获取最大值和最小值相等的区间的刻度
 *
 * @param  {Number}  value     最大值也是最小值
 * @param  {Integer} tickCount 刻度数
 * @return {Array}   刻度组
 */
function getTickOfSingleValue(value, tickCount) {
  var isFlt = _arithmetic2.default.isFloat(value);
  var step = 1;
  // 计算刻度的一个中间值
  var middle = value;

  if (isFlt) {
    var absVal = Math.abs(value);

    if (absVal < 1) {
      // 小于1的浮点数，刻度的间隔也计算得到一个浮点数
      step = Math.pow(10, _arithmetic2.default.getDigitCount(value) - 1);

      middle = _arithmetic2.default.multiply(Math.floor(value / step), step);
    } else if (absVal > 1) {
      // 大于1的浮点数，向下取最接近的整数作为一个刻度
      middle = Math.floor(value);
    }
  } else if (value === 0) {
    middle = Math.floor((tickCount - 1) / 2);
  }

  var middleIndex = Math.floor((tickCount - 1) / 2);

  var fn = (0, _utils.compose)((0, _utils.map)(function (n) {
    return _arithmetic2.default.sum(middle, _arithmetic2.default.multiply(n - middleIndex, step));
  }), _utils.range);

  return fn(0, tickCount);
}

/**
 * 计算步长
 *
 * @param  {Number}  min        最小值
 * @param  {Number}  max        最大值
 * @param  {Integer} tickCount  刻度数
 * @param  {Number}  amendIndex 修正系数
 * @return {Object}  步长相关对象
 */
function calculateStep(min, max, tickCount) {
  var amendIndex = arguments.length <= 3 || arguments[3] === undefined ? 0 : arguments[3];

  // 获取间隔步长
  var step = getFormatStep((max - min) / (tickCount - 1), amendIndex);
  // 计算刻度的一个中间值
  var middle = undefined;

  // 当0属于取值范围时
  if (min <= 0 && max >= 0) {
    middle = 0;
  } else {
    middle = (min + max) / 2;
    middle = middle - middle % step;
  }

  var belowCount = Math.ceil((middle - min) / step);
  var upCount = Math.ceil((max - middle) / step);
  var scaleCount = belowCount + upCount + 1;

  if (scaleCount > tickCount) {
    // 当计算得到的刻度数大于需要的刻度数时，将步长修正的大一些
    return calculateStep(min, max, tickCount, amendIndex + 1);
  } else if (scaleCount < tickCount) {
    // 当计算得到的刻度数小于需要的刻度数时，人工的增加一些刻度
    upCount = max > 0 ? upCount + (tickCount - scaleCount) : upCount;
    belowCount = max > 0 ? belowCount : belowCount + (tickCount - scaleCount);
  }

  return {
    step: step,
    tickMin: _arithmetic2.default.minus(middle, _arithmetic2.default.multiply(belowCount, step)),
    tickMax: _arithmetic2.default.sum(middle, _arithmetic2.default.multiply(upCount, step))
  };
}
/**
 * 获取刻度
 *
 * @param  {Number}  min        最小值
 * @param  {Number}  max        最大值
 * @param  {Integer} tickCount  刻度数
 * @return {Array}   取刻度数组
 */
function getTickValues(_ref3) {
  var _ref4 = _slicedToArray(_ref3, 2);

  var min = _ref4[0];
  var max = _ref4[1];
  var tickCount = arguments.length <= 1 || arguments[1] === undefined ? 6 : arguments[1];

  // 刻度的数量不能小于1
  var count = Math.max(tickCount, 2);

  var _getValidInterval = getValidInterval([min, max]);

  var _getValidInterval2 = _slicedToArray(_getValidInterval, 2);

  var cormin = _getValidInterval2[0];
  var cormax = _getValidInterval2[1];

  if (cormin === cormax) {
    return getTickOfSingleValue(cormin, tickCount);
  }

  // 获取间隔步长

  var _calculateStep = calculateStep(cormin, cormax, count);

  var step = _calculateStep.step;
  var tickMin = _calculateStep.tickMin;
  var tickMax = _calculateStep.tickMax;

  var values = _arithmetic2.default.rangeStep(tickMin, tickMax + 0.1 * step, step);

  return min > max ? (0, _utils.reverse)(values) : values;
}

exports.default = (0, _utils.memoize)(getTickValues);