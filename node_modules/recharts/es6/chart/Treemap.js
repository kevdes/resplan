'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _isFunction2 = require('lodash/isFunction');

var _isFunction3 = _interopRequireDefault(_isFunction2);

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _class, _class2, _temp2;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; /**
                                                                                                                                                                                                                                                                   * @fileOverview TreemapChart
                                                                                                                                                                                                                                                                   */


var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _Surface = require('../container/Surface');

var _Surface2 = _interopRequireDefault(_Surface);

var _Layer = require('../container/Layer');

var _Layer2 = _interopRequireDefault(_Layer);

var _Rectangle = require('../shape/Rectangle');

var _Rectangle2 = _interopRequireDefault(_Rectangle);

var _ReactUtils = require('../util/ReactUtils');

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _reactSmooth = require('react-smooth');

var _reactSmooth2 = _interopRequireDefault(_reactSmooth);

var _Tooltip = require('../component/Tooltip');

var _Tooltip2 = _interopRequireDefault(_Tooltip);

var _PureRender = require('../util/PureRender');

var _PureRender2 = _interopRequireDefault(_PureRender);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var computeNode = function computeNode(depth, node, index, valueKey) {
  var children = node.children;

  var childDepth = depth + 1;
  var computedChildren = children && children.length ? children.map(function (child, i) {
    return computeNode(childDepth, child, i, valueKey);
  }) : null;
  var value = void 0;

  if (children && children.length) {
    value = computedChildren.reduce(function (result, child) {
      return result + child.value;
    }, 0);
  } else {
    value = isNaN(node[valueKey]) || node[valueKey] <= 0 ? 0 : node[valueKey];
  }

  return _extends({}, node, {
    children: computedChildren,
    value: value, depth: depth, index: index
  });
};

var pad = function pad(node) {
  return { x: node.x, y: node.y, width: node.width, height: node.height };
};

// Compute the area for each child based on value & scale.
var scale = function scale(children, k) {
  var formatK = k < 0 ? 0 : k;

  return children.map(function (child) {
    var area = child.value * formatK;

    return _extends({}, child, {
      area: isNaN(area) || area <= 0 ? 0 : area
    });
  });
};

// Computes the score for the specified row, as the worst aspect ratio.
var worst = function worst(row, size, ratio) {
  var newSize = size * size;
  var rowArea = row.area * row.area;

  var _row$reduce = row.reduce(function (result, child) {
    return {
      min: Math.min(result.min, child.area),
      max: Math.max(result.max, child.area)
    };
  }, { min: Infinity, max: 0 });

  var min = _row$reduce.min;
  var max = _row$reduce.max;


  return rowArea ? Math.max(newSize * max * ratio / rowArea, rowArea / (newSize * min * ratio)) : Infinity;
};

// Positions the specified row of nodes. Modifies `rect`.
var position = function position(row, size, rect, flush) {
  var i = -1;
  var n = row.length;
  var x = rect.x;
  var y = rect.y;
  var v = size ? Math.round(row.area / size) : 0;
  var o = void 0;

  if (size === rect.width) {
    // horizontal subdivision
    if (flush || v > rect.height) v = rect.height; // over+underflow
    while (++i < n) {
      o = row[i];
      o.x = x;
      o.y = y;
      o.height = v;
      x += o.width = Math.min(rect.x + rect.width - x, v ? Math.round(o.area / v) : 0);
    }
    o.z = true;
    o.width += rect.x + rect.width - x; // rounding error
    rect.y += v;
    rect.height -= v;
  } else {
    // vertical subdivision
    if (flush || v > rect.width) v = rect.width; // over+underflow
    while (++i < n) {
      o = row[i];
      o.x = x;
      o.y = y;
      o.width = v;
      y += o.height = Math.min(rect.y + rect.height - y, v ? Math.round(o.area / v) : 0);
    }
    o.z = false;
    o.height += rect.y + rect.height - y; // rounding error
    rect.x += v;
    rect.width -= v;
  }
};

// Recursively arranges the specified node's children into squarified rows.
var squarify = function squarify(node, ratio) {
  var children = node.children;

  if (children && children.length) {
    var rect = pad(node);
    var row = [];
    var best = Infinity; // the best row score so far
    var score = void 0; // the current row score
    var size = Math.min(rect.width, rect.height); // initial orientation
    var scaleChildren = scale(children, rect.width * rect.height / node.value);
    var tempChildren = scaleChildren.slice();

    row.area = 0;

    var child = void 0;

    while (tempChildren.length > 0) {
      row.push(child = tempChildren[0]);
      row.area += child.area;

      score = worst(row, size, ratio);
      if (score <= best) {
        // continue with this orientation
        tempChildren.shift();
        best = score;
      } else {
        // abort, and try a different orientation
        row.area -= row.pop().area;
        position(row, size, rect, false);
        size = Math.min(rect.width, rect.height);
        row.length = row.area = 0;
        best = Infinity;
      }
    }
    if (row.length) {
      position(row, size, rect, true);
      row.length = row.area = 0;
    }

    return _extends({}, node, { children: scaleChildren.map(function (c) {
        return squarify(c, ratio);
      }) });
  }

  return node;
};

var Treemap = (0, _PureRender2.default)(_class = (_temp2 = _class2 = function (_Component) {
  _inherits(Treemap, _Component);

  function Treemap() {
    var _Object$getPrototypeO;

    var _temp, _this, _ret;

    _classCallCheck(this, Treemap);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_Object$getPrototypeO = Object.getPrototypeOf(Treemap)).call.apply(_Object$getPrototypeO, [this].concat(args))), _this), _this.state = {
      isTooltipActive: false,
      activeNode: null
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  _createClass(Treemap, [{
    key: 'handleMouseEnter',
    value: function handleMouseEnter(node, e) {
      var _props = this.props;
      var onMouseEnter = _props.onMouseEnter;
      var children = _props.children;

      var tooltipItem = (0, _ReactUtils.findChildByType)(children, _Tooltip2.default);

      if (tooltipItem) {
        this.setState({
          isTooltipActive: true,
          activeNode: node
        }, function () {
          if (onMouseEnter) {
            onMouseEnter(node, e);
          }
        });
      } else if (onMouseEnter) {
        onMouseEnter(node, e);
      }
    }
  }, {
    key: 'handleMouseLeave',
    value: function handleMouseLeave(node, e) {
      var _props2 = this.props;
      var onMouseLeave = _props2.onMouseLeave;
      var children = _props2.children;

      var tooltipItem = (0, _ReactUtils.findChildByType)(children, _Tooltip2.default);

      if (tooltipItem) {
        this.setState({
          isTooltipActive: false,
          activeNode: null
        }, function () {
          if (onMouseLeave) {
            onMouseLeave(node, e);
          }
        });
      } else if (onMouseLeave) {
        onMouseLeave(node, e);
      }
    }
  }, {
    key: 'handleClick',
    value: function handleClick(node) {
      var onClick = this.props.onClick;


      if (onClick) {
        onClick(node);
      }
    }
  }, {
    key: 'renderAnimatedItem',
    value: function renderAnimatedItem(content, nodeProps, isLeaf) {
      var _this2 = this;

      var _props3 = this.props;
      var isAnimationActive = _props3.isAnimationActive;
      var animationBegin = _props3.animationBegin;
      var animationDuration = _props3.animationDuration;
      var animationEasing = _props3.animationEasing;
      var isUpdateAnimationActive = _props3.isUpdateAnimationActive;
      var width = nodeProps.width;
      var height = nodeProps.height;
      var x = nodeProps.x;
      var y = nodeProps.y;

      var translateX = parseInt((Math.random() * 2 - 1) * width, 10);
      var translateY = parseInt((Math.random() * 2 - 1) * height, 10);
      var event = {};

      if (isLeaf) {
        event = {
          onMouseEnter: this.handleMouseEnter.bind(this, nodeProps),
          onMouseLeave: this.handleMouseLeave.bind(this, nodeProps),
          onClick: this.handleClick.bind(this, nodeProps)
        };
      }

      return _react2.default.createElement(
        _reactSmooth2.default,
        {
          from: { x: x, y: y, width: width, height: height },
          to: { x: x, y: y, width: width, height: height },
          duration: animationDuration,
          easing: animationEasing,
          isActive: isUpdateAnimationActive
        },
        function (_ref) {
          var currX = _ref.x;
          var currY = _ref.y;
          var currWidth = _ref.width;
          var currHeight = _ref.height;
          return _react2.default.createElement(
            _reactSmooth2.default,
            {
              from: 'translate(' + translateX + 'px, ' + translateX + 'px)',
              to: 'translate(0, 0)',
              attributeName: 'transform',
              begin: animationBegin,
              easing: animationEasing,
              isActive: isAnimationActive,
              duration: animationDuration
            },
            _react2.default.createElement(
              _Layer2.default,
              event,
              _this2.renderContentItem(content, _extends({}, nodeProps, {
                isAnimationActive: isAnimationActive,
                isUpdateAnimationActive: !isUpdateAnimationActive,
                width: currWidth,
                height: currHeight,
                x: currX,
                y: currY
              }))
            )
          );
        }
      );
    }
  }, {
    key: 'renderContentItem',
    value: function renderContentItem(content, nodeProps) {
      if (_react2.default.isValidElement(content)) {
        return _react2.default.cloneElement(content, nodeProps);
      } else if ((0, _isFunction3.default)(content)) {
        return content(nodeProps);
      }

      return _react2.default.createElement(_Rectangle2.default, nodeProps);
    }
  }, {
    key: 'renderNode',
    value: function renderNode(root, node, i) {
      var _this3 = this;

      var content = this.props.content;

      var nodeProps = _extends({}, (0, _ReactUtils.getPresentationAttributes)(this.props), node, { root: root });
      var isLeaf = !node.children || !node.children.length;

      return _react2.default.createElement(
        _Layer2.default,
        { key: 'recharts-treemap-node-' + i },
        this.renderAnimatedItem(content, nodeProps, isLeaf),
        node.children && node.children.length ? node.children.map(function (child, index) {
          return _this3.renderNode(node, child, index);
        }) : null
      );
    }
  }, {
    key: 'renderAllNodes',
    value: function renderAllNodes() {
      var _props4 = this.props;
      var width = _props4.width;
      var height = _props4.height;
      var data = _props4.data;
      var dataKey = _props4.dataKey;
      var ratio = _props4.ratio;


      var root = computeNode(0, {
        children: data,
        x: 0,
        y: 0,
        width: width,
        height: height
      }, 0, dataKey);

      var formatRoot = squarify(root, ratio);

      return this.renderNode(formatRoot, formatRoot, 0);
    }
  }, {
    key: 'renderTooltip',
    value: function renderTooltip(items, offset) {
      var children = this.props.children;

      var tooltipItem = (0, _ReactUtils.findChildByType)(children, _Tooltip2.default);

      if (!tooltipItem) {
        return null;
      }

      var _props5 = this.props;
      var width = _props5.width;
      var height = _props5.height;
      var dataKey = _props5.dataKey;
      var _state = this.state;
      var isTooltipActive = _state.isTooltipActive;
      var activeNode = _state.activeNode;

      var viewBox = { x: 0, y: 0, width: width, height: height };
      var coordinate = activeNode ? {
        x: activeNode.x + activeNode.width / 2,
        y: activeNode.y + activeNode.height / 2
      } : null;
      var payload = isTooltipActive && activeNode ? [{
        name: '', value: activeNode[dataKey]
      }] : [];

      return _react2.default.cloneElement(tooltipItem, {
        viewBox: viewBox,
        active: isTooltipActive,
        coordinate: coordinate,
        label: '',
        payload: payload,
        separator: ''
      });
    }
  }, {
    key: 'render',
    value: function render() {
      if (!(0, _ReactUtils.validateWidthHeight)(this)) {
        return null;
      }

      var _props6 = this.props;
      var width = _props6.width;
      var height = _props6.height;
      var className = _props6.className;
      var style = _props6.style;
      var children = _props6.children;


      return _react2.default.createElement(
        'div',
        {
          className: (0, _classnames2.default)('recharts-wrapper', className),
          style: _extends({ position: 'relative', cursor: 'default' }, style)
        },
        _react2.default.createElement(
          _Surface2.default,
          { width: width, height: height },
          this.renderAllNodes(),
          (0, _ReactUtils.filterSvgElements)(children)
        ),
        this.renderTooltip()
      );
    }
  }]);

  return Treemap;
}(_react.Component), _class2.displayName = 'Treemap', _class2.propTypes = {
  width: _react.PropTypes.number,
  height: _react.PropTypes.number,
  data: _react.PropTypes.array,
  style: _react.PropTypes.object,
  ratio: _react.PropTypes.number,
  content: _react.PropTypes.oneOfType([_react.PropTypes.element, _react.PropTypes.func]),
  fill: _react.PropTypes.string,
  stroke: _react.PropTypes.string,
  className: _react.PropTypes.string,
  dataKey: _react.PropTypes.string,
  children: _react.PropTypes.oneOfType([_react.PropTypes.arrayOf(_react.PropTypes.node), _react.PropTypes.node]),

  onMouseEnter: _react.PropTypes.func,
  onMouseLeave: _react.PropTypes.func,
  onClick: _react.PropTypes.func,

  isAnimationActive: _react.PropTypes.bool,
  isUpdateAnimationActive: _react.PropTypes.bool,
  animationBegin: _react.PropTypes.number,
  animationDuration: _react.PropTypes.number,
  animationEasing: _react.PropTypes.oneOf(['ease', 'ease-in', 'ease-out', 'ease-in-out', 'linear'])
}, _class2.defaultProps = {
  fill: '#fff',
  stroke: '#000',
  dataKey: 'value',
  ratio: 0.5 * (1 + Math.sqrt(5)),
  isAnimationActive: true,
  isUpdateAnimationActive: true,
  animationBegin: 0,
  animationDuration: 1500,
  animationEasing: 'linear'
}, _temp2)) || _class;

exports.default = Treemap;